<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/06/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Algorithms</title>
    <url>/2023/06/26/Algorithms/</url>
    <content><![CDATA[<p>The great algorithms are the poetry of computation - Francis Sullivan</p>
<h1 id="Section-one-Fundamentals"><a href="#Section-one-Fundamentals" class="headerlink" title="Section one: Fundamentals"></a>Section one: Fundamentals</h1><h2 id="Steps-for-buiding-algorithm"><a href="#Steps-for-buiding-algorithm" class="headerlink" title="Steps for buiding algorithm:"></a>Steps for buiding algorithm:</h2><ul>
<li>Model the problem</li>
<li>Find an algorithm</li>
<li>Fast? Fits in memory?</li>
<li>Find a why to address problem if not, iterate untill satisified</li>
</ul>
<hr>
<h2 id="1-Union-Find"><a href="#1-Union-Find" class="headerlink" title="1. Union-Find"></a>1. Union-Find</h2><h3 id="1-1-Dynamic-connectivity"><a href="#1-1-Dynamic-connectivity" class="headerlink" title="1.1 Dynamic connectivity"></a>1.1 Dynamic connectivity</h3><h4 id="Problem-desceription"><a href="#Problem-desceription" class="headerlink" title="Problem desceription:"></a><em>Problem desceription</em>:</h4><p>Given a set of N objects.</p>
<ul>
<li>Union command: connect two objects.</li>
<li>Find/connected query: is there a path connecting the two objects?</li>
</ul>
<h4 id="Problem-Modeling"><a href="#Problem-Modeling" class="headerlink" title="Problem Modeling:"></a><em>Problem Modeling</em>:</h4><p><em>“is connected to”</em>:</p>
<ul>
<li>Reflexive: p is connected to p.</li>
<li>Symmetric: if p is connected to q, then q is connected to p.</li>
<li>Transitive: if p is connected to q and q is connected to r,<br>then p is connected to r</li>
</ul>
<p><em>Connected components</em>: Maximal set of objects that are mutually<br>connected.</p>
<p><img src="/2023/06/26/Algorithms/1.jpg" alt="Fig.1"></p>
<p><em>Find query</em>: Check if two objects are in the same component.</p>
<p><em>Union</em>: Replace compenents containing two obejects with their union. i.e., if we union(2,5) for Figure 1</p>
<p><em>Union-find data type</em>:<br><img src="/2023/06/26/Algorithms/2.jpg" alt="Fig.2"></p>
<h3 id="1-2-Solution-1-Quick-find-eager-approach"><a href="#1-2-Solution-1-Quick-find-eager-approach" class="headerlink" title="1.2 Solution 1: Quick find (eager approach)"></a>1.2 Solution 1: Quick find (eager approach)</h3><p><em>Data Structure</em>:</p>
<ul>
<li>Integer array id[] of size N.</li>
<li>Interpretation: p and q are cooneted iff have the same id.<br><img src="/2023/06/26/Algorithms/3.jpg" alt="Fig.3"></li>
</ul>
<p><em>Solution</em>:</p>
<ul>
<li>Find: Check if p and q have the same id</li>
<li>Union: If union p and q, change id[p] to id[q]</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindUF</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    pulic <span class="title function_">QuickFindUF</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">            id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;N; i++&gt;) id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[p] == id[q]</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pid</span> <span class="operator">=</span> id[p];</span><br><span class="line">        <span class="type">int</span> <span class="variable">qid</span> <span class="operator">=</span> idp[q];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> = <span class="number">0</span>; i &lt; id.leangth; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (id[i]==pid) id[i] = qid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Solution-2-Quick-union"><a href="#1-3-Solution-2-Quick-union" class="headerlink" title="1.3 Solution 2: Quick union"></a>1.3 Solution 2: Quick union</h3><p><em>Data Structure</em>: </p>
<ul>
<li><font color="blue">Integer</font> array id[] of size N</li>
<li>id[i] is parent of i (continue untill id[i]==i), so the root of i is id[id[…id[i]…]]</li>
</ul>
<p><em>Solution</em>:</p>
<ul>
<li>Find: Check if p and q have the same root</li>
<li>Union: Set the if of p’s root to q’s root  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickFindUF</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] id;</span><br><span class="line"></span><br><span class="line">    pulic <span class="title function_">QuickFindUF</span><span class="params">(<span class="type">int</span> N)</span></span><br><span class="line">    &#123;</span><br><span class="line">        id = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;N; i++&gt;) id[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != id[i]) i = id[i];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root(p) == root(q);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> root(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> root(q);</span><br><span class="line">        id[i] = j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-Solution-3-Quick-union-improved"><a href="#1-4-Solution-3-Quick-union-improved" class="headerlink" title="1.4 Solution 3: Quick union improved"></a>1.4 Solution 3: Quick union improved</h3><p><em>Imporve 1: weighting</em>:</p>
<ul>
<li>Keep track of <strong>size</strong> of each tree, balance by linking root of smaller tree to larger tree (determine which tree is bigger)</li>
</ul>
<p><em>Solution</em>:</p>
<ul>
<li>Data structure: based on quick-union, maintain extra array sz[i] to count number of objects in the tree </li>
<li>Find: identical to quick-union</li>
<li>Union: <ul>
<li>Link root of smaller tree to lager</li>
<li>Update the sz[] array</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> root(p);</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> root(q);</span><br><span class="line"><span class="keyword">if</span> (i == j) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sz[i] &lt; sz[j]) &#123;id[i] = j; sz[j] += sz[i] &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;id[j] = i; sz[i] += sz[j] &#125;</span><br></pre></td></tr></table></figure>
<p><em>Running time</em>:</p>
<ul>
<li>Find: takes time proportional to depth of p and q</li>
<li>Union: takes constant time, given roots</li>
</ul>
<p><em>Proposition</em>: Depth of any node x is at most $lgN$(base-2 logarithm). The least number of nodes to get a tree with height h is $2^(h-1)$, so $h = lgN + 1 $\approx$ logN $ (PS: the height won’t increase unless two trees have the same height)<br><img src="/2023/06/26/Algorithms/4.jpg" alt="Fig.4"></p>
<p><em>Improve 2: path compression</em></p>
<ul>
<li>After computing the root of p, set the id of each examined node to point to that root.</li>
<li>Make every other node in path points to its grandparents</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">root</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i != id[i]) &#123;</span><br><span class="line">        id[i] = id[id[i]];</span><br><span class="line">        i = id[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>order of growth of number of array accesses</em>:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>algorithm</th>
<th>initialize</th>
<th>union</th>
<th>find</th>
<th>worst-case time</th>
</tr>
</thead>
<tbody>
<tr>
<td>quick-find</td>
<td>N</td>
<td>N</td>
<td>1</td>
<td>MN</td>
</tr>
<tr>
<td>quick-union</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>MN</td>
</tr>
<tr>
<td>weighted QU</td>
<td>N</td>
<td>lgN</td>
<td>lgN</td>
<td>N + MlogN</td>
</tr>
<tr>
<td>QU + path compression</td>
<td>N</td>
<td>\</td>
<td>\</td>
<td>N + MlogN</td>
</tr>
<tr>
<td>weighted q-u</td>
<td>N</td>
<td>\</td>
<td>\</td>
<td>N + MlogN</td>
</tr>
</tbody>
</table>
</div>
<p><em>Disadvantage</em>:</p>
<ul>
<li>Quick-find: Union is too expensive, trees are flat (takes $N^2$ array access to process N union commands on N objects)</li>
<li>Quick Union: Trees can get tall. The find could be too expensive</li>
</ul>
<h3 id="1-5-QU-Applications"><a href="#1-5-QU-Applications" class="headerlink" title="1.5 QU Applications"></a>1.5 QU Applications</h3><h4 id="1-5-1-Percolation"><a href="#1-5-1-Percolation" class="headerlink" title="1.5.1 Percolation"></a>1.5.1 Percolation</h4>]]></content>
  </entry>
</search>
